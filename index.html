<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image â†’ FH2M Map</title>

<style>
/* -----------------------------
   FONTS & BASE
----------------------------- */
@font-face {
  font-family: "HoMM";
  src: local("Trebuchet MS");
}

:root {
  --bg-dark: #1b1a17;
  --panel-bg: #d8c9a3;
  --panel-border: #5a4522;
  --gold: #c9a441;
  --gold-dark: #8a6a1f;
  --text-dark: #2b1f0f;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-height: 100vh;
  font-family: Arial, serif;
  background: radial-gradient(circle at top, #2c2a25, #0f0f0f);
  display: grid;
  gap: 16px;
  justify-content: center;
  color: var(--text-dark);
}

/* -----------------------------
   PANEL
----------------------------- */
.panel {
  margin: 10px;
  background: linear-gradient(#e6d8b5, var(--panel-bg));
  border: 4px solid var(--panel-border);
  box-shadow:
    inset 0 0 0 2px #f5e9c9,
    0 12px 40px rgba(0,0,0,0.6);
  padding: 20px;
  border-radius: 6px;
  display: grid;
  justify-content: center;
}

/* -----------------------------
   TITLE
----------------------------- */
.panel h1 {
  text-align: center;
  margin: 0 0 14px;
  font-size: 20px;
  letter-spacing: 1px;
  text-shadow: 1px 1px #fff;
}

/* -----------------------------
   CONTROLS
----------------------------- */
.controls {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

input[type="file"] {
  background: #f3ead0;
  border: 2px solid var(--panel-border);
  padding: 6px;
  font-size: 14px;
}

button {
  background: linear-gradient(#f4d77a, var(--gold));
  border: 2px solid var(--gold-dark);
  padding: 10px;
  font-size: 15px;
  font-weight: bold;
  color: #3a2a0c;
  cursor: pointer;
  box-shadow:
    inset 0 1px 0 #fff,
    0 3px 0 #6d5320;
}

button:hover {
  filter: brightness(1.05);
}

button:active {
  transform: translateY(2px);
  box-shadow:
    inset 0 1px 0 #fff,
    0 1px 0 #6d5320;
}

/* -----------------------------
   CANVAS
----------------------------- */
.preview {
  margin-top: 16px;
  text-align: center;
}

canvas {
  width: 100%;
  max-width: 256px;
  aspect-ratio: 1;
  border: 3px solid var(--panel-border);
  background: #000;
  image-rendering: pixelated;
}

/* -----------------------------
   RESPONSIVE
----------------------------- */
@media (max-width: 480px) {
  .panel {
    padding: 16px;
  }

  .panel h1 {
    font-size: 18px;
  }
}

img {
  width: auto;
  max-width: 100%;
  margin: 0 auto;
}

.separator {
  font-size: 148px;
  color: var(--gold);
  display: flex;
  justify-content: center;
}

</style>
</head>

<body>

<div class="panel">
  <h1>ðŸŒ¸Image â†’ <a href="https://github.com/ihhub/fheroes2">fheroes2</a> âœ…map</h1>
  <p>
    Browser-based generator of fheroes2 maps (*.fh2m) from images with automatic terrain detection.
  </p>

  <div class="controls">
    <input type="file" id="file" accept="image/*">
    <button onclick="processImage()">Generate map</button>
  </div>
  <img src="check-mark.gif" width="72" height="72" />

  <div class="preview">
    <canvas id="canvas" width="144" height="144"></canvas>
  </div>
</div>

<img src="one-piece-high-quality-anime-png-file-hd.png"/>
<div class="separator">â¬‡</div>
<img src="screenshot.png"/>

<script>
/* --------------------------------------------------
   Terrain palette
-------------------------------------------------- */

function buildTerrainPalette() {
  const palette = []

  const terrains = [
    { base:[30,95,175], start:0, offset:16, count:4 },      // water
    { base:[45,145,55], start:30, offset:38, count:8 },     // grass
    { base:[235,235,245], start:92, offset:38, count:8 },   // snow
    { base:[70,95,70], start:146, offset:38, count:8 },     // swamp
    { base:[175,75,55], start:208, offset:38, count:8 },    // lava
    { base:[215,185,90], start:262, offset:38, count:8 },   // desert
    { base:[155,105,65], start:321, offset:16, count:8 },   // dirt
    { base:[135,125,115], start:361, offset:38, count:8 },  // wasteland
    { base:[235,225,185], start:415, offset:0, count:8 }    // beach
  ]

  for (const t of terrains) {
    const minF = t.count <= 4 ? 0.85 : 0.75
    const maxF = t.count <= 4 ? 1.15 : 1.25

    for (let i = 0; i < t.count; i++) {
      const f = minF + (maxF - minF) * (i / (t.count - 1))
      palette.push({
        index: t.start + t.offset + i,
        r: Math.min(255, Math.round(t.base[0] * f)),
        g: Math.min(255, Math.round(t.base[1] * f)),
        b: Math.min(255, Math.round(t.base[2] * f))
      })
    }
  }

  return palette
}

const PALETTE = buildTerrainPalette()

/* --------------------------------------------------
   Utils
-------------------------------------------------- */

function pickMapSize(w, h) {
  const m = Math.max(w, h)
  if (m <= 36) return 36
  if (m <= 72) return 72
  if (m <= 108) return 108
  return 144
}

function closestTerrain(r, g, b) {
  let best = 0
  let bestDist = 1e9

  for (const t of PALETTE) {
    const dr = r - t.r
    const dg = g - t.g
    const db = b - t.b
    const d = dr*dr + dg*dg + db*db
    if (d < bestDist) {
      bestDist = d
      best = t.index
      if (d === 0) break
    }
  }
  return best
}

/* --------------------------------------------------
   Binary writer (big endian)
-------------------------------------------------- */

class BinWriter {
  constructor() {
    this.data = []
  }
  u8(v){ this.data.push(v & 255) }
  u16(v){ this.u8(v>>8); this.u8(v) }
  u32(v){ this.u8(v>>24); this.u8(v>>16); this.u8(v>>8); this.u8(v) }
  str(s){
    const b = new TextEncoder().encode(s)
    this.u32(b.length)
    this.data.push(...b)
  }
  bytes(){ return new Uint8Array(this.data) }
}

/* --------------------------------------------------
   FH2M build
-------------------------------------------------- */

async function buildFH2M(tileIndices, size, name) {
  const payload = new BinWriter()

  payload.u32(0) // additionalInfo
  payload.u32(tileIndices.length)

  for (const t of tileIndices) {
    payload.u16(t)
    payload.u8(0)
    payload.u32(0)
  }

  payload.u32(0) // events
  payload.u32(0) // rumors

  for (let i=0;i<9;i++) payload.u32(0)

  const compressed = await compressZlib(payload.bytes())

  const out = new BinWriter()

  out.u8(0x68); out.u8(0x32); out.u8(0x6D)
  out.u8(0x61); out.u8(0x70); out.u8(0)

  out.u16(10)
  out.u8(0)
  out.u8(1)

  out.u8(1); out.u8(1); out.u8(0)
  out.u32(0)

  out.u32(6)
  out.u8(0x80); for(let i=0;i<5;i++) out.u8(0)

  out.u8(0); out.u8(1); out.u8(1); out.u32(0)
  out.u8(0); out.u32(0)

  out.u32(size)
  out.u8(0)

  out.str(name)
  out.str(`Generated from image (${size}x${size})`)
  out.str("auto")

  return new Blob([out.bytes(), compressed], {type:'application/octet-stream'})
}

/* --------------------------------------------------
   zlib via CompressionStream
-------------------------------------------------- */

async function compressZlib(data) {
  const cs = new CompressionStream('deflate')
  const writer = cs.writable.getWriter()
  writer.write(data)
  writer.close()
  const buf = await new Response(cs.readable).arrayBuffer()
  return new Uint8Array(buf)
}

/* --------------------------------------------------
   Main
-------------------------------------------------- */

async function processImage() {
  const file = document.getElementById('file').files[0]
  if (!file) return

  const img = new Image()
  img.src = URL.createObjectURL(file)
  await img.decode()

  const size = pickMapSize(img.width, img.height)
  const canvas = document.getElementById('canvas')
  canvas.width = canvas.height = size
  const ctx = canvas.getContext('2d')

  const s = Math.min(img.width, img.height)
  ctx.drawImage(
    img,
    (img.width - s)/2,
    (img.height - s)/2,
    s, s,
    0, 0,
    size, size
  )

  const imgData = ctx.getImageData(0,0,size,size).data
  const tiles = []

  for (let i=0;i<imgData.length;i+=4) {
    let r = imgData[i]
    let g = imgData[i+1]
    let b = imgData[i+2]
    let a = imgData[i+3]

    if (a !== 255) {
      r = (r*a + 255*(255-a))/255
      g = (g*a + 255*(255-a))/255
      b = (b*a + 255*(255-a))/255
    }

    tiles.push(closestTerrain(r,g,b))
  }

  const blob = await buildFH2M(tiles, size, file.name.replace(/\..+$/, ''))

  const a = document.createElement('a')
  a.href = URL.createObjectURL(blob)
  a.download = file.name.replace(/\..+$/, '.fh2m')
  a.click()
}
</script>

</body>
</html>
